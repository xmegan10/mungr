---
title: "mungr_demo"
author: "Megan Xiao"
date: "2025-11-20"
output: github_document
---

```{r}
library(tidyr)
library(dplyr)
library(naniar)
library(ggplot2)
```


## Data Advice and Cleaning
```{r}
set.seed(42)

generate_messy_df <- function(){
  Names <- c("alice ", "BOB", "Charlie", "david", "EVE   ", NA, "frank", "", "grace", "Heidi", "unknown","JOE","john","Bill"," GRACE ","jerry","arnold")
Categories <- c(
    "ACTIVE", "inactive", "PENDING", "Active", "inactive", NA, "active", "", 
    "pending", "Active", "Unknown"
  )
Prices <- c("$100.50", "200.00", "300.75", "450", "Error", NA, "$10", "150.25", 
    "350", "225","300"," $2.50 ")
Is_Client <- sample(c(0, 1, 1.0, 0.0, NA), 100, replace = TRUE, prob = c(0.4, 0.4, 0.1, 0.05, 0.05))
Satisfaction_Rating <- c(sample(c("1","2","3",4.0,5), 100, replace = TRUE, prob = c(0.3, 0.2, 0.2, 0.1, 0.1)))
Dates <- c(
    "2023-01-01", "02/03/2023", "20230405", NA, "2023-10-20", "", 
    "2023-11-25", "2023-12-01", "2024-01-01", "01/15/2024","2024-01-05","unknown","2023-01-02","2023-01-03"
  )
ID <- 1:100


messy_df <- tibble(
  ID = factor(ID),
  Name = sample(Names, 100, replace = TRUE),
  Status = sample(Categories, 100, replace = TRUE),
  Sale_Price = sample(Prices, 100, replace = TRUE),
  Satisfaction_Rating = Satisfaction_Rating,
  Is_Active = Is_Client,
  Transaction_Date = sample(Dates, 100, replace = TRUE),
  Notes_this_is_an_empty_column = "  "
)

return(messy_df)
}

messy_df <- generate_messy_df()
```

```{r}
#inspect dataframe
str(messy_df)
```


```{r}
#create object
cleaner <- MungrCleaner(messy_df)
print(cleaner)
```

```{r}
#get advice
cleaner <- get_advice(cleaner)
```
```{r}
cleaner <- clean_text(cleaner)
print(cleaner$data)
```

```{r}
cleaner <- standardize_strcols(cleaner)
print(cleaner$data)
```

```{r}
cleaner <- standardize_numcols(cleaner)
print(cleaner$data)
```
```{r}
cleaner <- impute_missing(cleaner, col_name = "Sale_Price")
print(cleaner$data)
```
```{r}
messy_df <- generate_messy_df()
```

```{r}
quick_cleaner <- MungrCleaner(messy_df)
quick_cleaner <- quick_clean(quick_cleaner)
print(cleaner$data)
```

```{r}
library(dplyr)
library(tidyr)
library(stringr)
library(lubridate)
```

```{r}
MungrCleaner <- function(df){
  if(!is.data.frame(df)) stop("Input must be a dataframe.")
  
  obj <- list(
    data = as_tibble(df),
    log = character()
  )
  class(obj) <- "MungrCleaner"
  return(obj)
}

print.MungrCleaner <- function(x,...){
  cat("MungrCleaner History\n")
  if(length(x$log) > 0) {
    cat("Status: Cleaned", length(x$log), "steps.\n")
    }else{
      cat("Status: No changes yet\n")
    }
  invisible(x)
  }
```

```{r}
#generic functions

#gives you general advice about your dataframe
get_advice <- function(x, ...) UseMethod("get_advice")

#reassigns column types based on simple patterns in each column.
standardize_strcols <- function(x, ...) UseMethod("standardize_strcols")

standardize_numcols <- function(x, ...) UseMethod("standardize_numcols")

#empty fields replaced by NA, optional choice to upper or lower case all strings, choice to remove trailing white spaces
clean_text <- function(x, ...) UseMethod("clean_text")

#fill NAs with a specific value or imput with mean/median/mode based on num_val = argument and char_val = "Unknown"
impute_missing <- function(x, ...) UseMethod("impute_missing")

#combines all methods into one. Allow users to quickly clean dataframe without worrying about pipelines. Users can choose which functions to keep
quick_clean <- function(x, ...) UseMethod("quick_clean")

```

```{r}
get_advice.MungrCleaner <- function(x, na_threshold = .5, factor_card_perc = .7, string_card_perc = 0.1,...){
  df <- x$data
  n_rows <- nrow(df)
  issues_found <- FALSE
  
if (factor_card_perc < 0.5) {
  warning(sprintf("Cardinality percentage (%.0f%%) for identifying factor/string columns with high amount of variance (suggesting possible char-type) is low. Consider setting a value closer to 70%% (0.7) or higher.", card_perc * 100))
}

if (string_card_perc > 0.2) {
  warning(sprintf("Cardinality percentage (%.0f%%) for identifying string columns with little variance (suggesting possible factor-type) is high. Consider setting a value closer to 10%% (0.1) or lower.", card_perc * 100))
}
  
  for(col_name in names(df)){
      col_data <- df[[col_name]]
      advice_list <- character()
      
      #Check Missing Data Severity
      n_na <- sum(is.na(col_data))
      if(n_na >0){
        percentage_is_na <- n_na/n_rows
        
        if(percentage_is_na > na_threshold){
          advice_list <- c(advice_list, sprintf("CRITICAL: %.0f%% missing. Consider dropping this column.", percentage_is_na *100))
        }else{
          advice_list <- c(advice_list, sprintf("Warning: %.0f%% missing. Consider imputing missing values with a custom value. If this is a numeric-type column, consider imputing values with mean, median, or mode", percentage_is_na*100))
        }
      }
      
    #Check empty strings (characters only)
    if (is.character(col_data) || is.factor(col_data)) {
      col_data_char <- as.character(col_data)
      n_empty <- sum(col_data_char == "", na.rm = TRUE)
      
      if (n_empty > 0) {
        advice_list <- c(advice_list, "Consistency Issue: Mixed empty strings and NAs. If empty fields aren't intentional, replace empty strings with this code: df[df == ''] <- NA")
      }
      
      # Check Case Sensitivity
      # If we lower-case everything, do we have fewer unique items? e.g., "Male", "male" -> "male" (2 items becomes 1)
      n_uniq_original <- length(unique(col_data_char))
      n_uniq_lower <- length(unique(tolower(col_data_char)))
      
      if (n_uniq_lower < n_uniq_original) {
        diff <- n_uniq_original - n_uniq_lower
        advice_list <- c(advice_list, sprintf("Formatting issue: Case inconsistency detected (%d duplicates). You have the same values counted as unique from each other due to case sensitivity. If this is not intentional, run: toupper() or tolower()", diff))
      }
      
      
      #Check for High Cardinality (Too many categories)
      # If a high percentage (card_perc) of the rows are unique, it's likely an ID or free text, not a category
      if (n_uniq_original > (n_rows * factor_card_perc)) {
         advice_list <- c(advice_list, sprintf("Datatype: There's a lot of unique categories; %.0f%% of your values are unique. This looks like an ID or free text.", (factor_card_perc)*100))
      }
      
      #Check for Unique Values (Column may be a category)
      uniq_ratio <- n_uniq_lower / n_rows
      if (uniq_ratio <= string_card_perc && n_uniq_lower > 1){
        advice_list <- c(advice_list, sprintf("Datatype: This column has low cardinality; %.1f%% of your column has variance. You may want to change this column to a factor-type.", uniq_ratio*100))
      }
    }
       #Check for Zero Variance (Useless column)
    # If there is only 1 unique value (and it's not just all NAs)
    if (length(unique(na.omit(col_data))) == 1) {
      advice_list <- c(advice_list, "Redundancy: Column has zero variance (same value for entire column). You might want to drop it.")
    }

    #Final results
    if (length(advice_list) > 0) {
      issues_found <- TRUE
      cat(sprintf("Column [%s]:\n", col_name))
      # Print advice with a bullet point
      cat(sprintf("  -> %s", advice_list), sep = "\n")
      cat("\n")
    }
      
  } #end of for loop
  if (!issues_found) {
    cat("No obvious data issues found. Good job!\n")
  }
  return(x)
  }
```

```{r}
standardize_strcols.MungrCleaner <- function(x, col_name = "", convert_to_numtype = TRUE, convert_to_cattype = TRUE, num_threshold = 0.7, date_threshold = 0.5, cat_threshold = 0.1, date_format = "ymd",...){
  #get dataframe
  df <- x$data
  cols_changed <- character()
  
  if(col_name == ""){
    cols_to_process <- names(df)
  } else {
    if(!col_name %in% names(df)) stop(paste("Column", col_name, "not found."))
    cols_to_prcocess <- col_name
  }
  
  #select date format
  date_parser <- switch(date_format,
                         "ymd" = lubridate::ymd,
                         "mdy" = lubridate::mdy,
                         "dmy" = lubridate::dmy,
                         lubridate::ymd)
  
  #start for loop
  for(col_name in names(df)){
    #check character columns
    if(is.character(df[[col_name]]) || is.factor(df[[col_name]])){
      vals <- as.character(df[[col_name]])
      non_na_vals <- vals[!is.na(vals) & vals != ""]
      
      if(length(non_na_vals) == 0) next #skip empty columns
      converted <- FALSE
      
      #---convert strings to boolean type---
      #----
      upper_vals <- toupper(unique(non_na_vals))
      valid_bools <- c("TRUE", "FALSE", "T", "F", "1", "0", "YES", "NO")
      
      if (all(upper_vals %in% valid_bools)) {
        try_bool <- as.logical(vals) 
        
        if (sum(is.na(try_bool)) / length(vals) < 0.1) {
           df[[col_name]] <- try_bool
           cols_changed <- c(cols_changed, paste0(col_name, " (-> Bool)"))
           converted <- TRUE
        }
      }
      
      if (converted) next
      
      #---convert string cols to numerical type---
      #----
      clean_vals <- gsub("[,%$]","", non_na_vals)
      num_vals <- suppressWarnings(as.numeric(clean_vals))
      
      ratio <- (sum(!is.na(num_vals))/length(non_na_vals))
      
      if(ratio >= num_threshold) {
        df[[col_name]] <- suppressWarnings(as.numeric(gsub("[,%$]","",df[[col_name]])))
        cols_changed <- c(cols_changed, paste0(col_name, " (-> Num)"))
        converted <- TRUE
      }
      
      if (converted) next
      
      #---convert string cols to date object---
      #----
      
      #try parsing
      try_dates <- suppressWarnings(date_parser(non_na_vals))
      
      date_ratio <- sum(!is.na(try_dates)) / length(non_na_vals)
      
      if(date_ratio >= date_threshold){
        df[[col_name]] <- suppressWarnings(date_parser(df[[col_name]]))
        cols_changed <- c(cols_changed, paste0(col_name, " (-> Date)"))
        converted <- TRUE
      }
      
      if (converted) next
      
      #---convert string cols to categorical object---
      #----
      uniq_ratio <- length(unique(non_na_vals)) / length(non_na_vals)
      
      if (uniq_ratio <= cat_threshold && length(unique(non_na_vals)) > 1) {
        df[[col_name]] <- as.factor(df[[col_name]])
        cols_changed <- c(cols_changed, paste0(col_name, " (-> Factor)"))
        converted <- TRUE
      }
      
    } # End is.character check
  } # End Loop
  
  # 3. Update Object
  x$data <- df
  
  # 4. Log results
  if (length(cols_changed) > 0) {
    msg <- sprintf("Standardize Str Col Types: Converted %d columns: [%s]", 
                   length(cols_changed), paste(cols_changed, collapse = ", "))
    x$log <- c(x$log, msg)
  } else {
    x$log <- c(x$log, "Standardize Str Col Types: No columns met conversion thresholds.")
  }
  
  return(x)
}
```

```{r}
standardize_numcols.MungrCleaner <- function(x, col_name = "", convert_bool = TRUE, convert_factor = TRUE, convert_int = TRUE, cat_threshold = 0.1, ...){
  #get dataframe
  df <- x$data
  cols_changed <- character()
  
  if(col_name == ""){
    cols_to_process <- names(df)
  } else {
    if(!col_name %in% names(df)) stop(paste("Column", col_name, "not found."))
    cols_to_process <- col_name
  }
  
  #start for loop
  for(col_name in names(df)){
    #check character columns
    if(is.numeric(df[[col_name]])){
      vals <- df[[col_name]]
      non_na_vals <- vals[!is.na(vals)]
      
      if(length(non_na_vals) == 0) next #skip empty columns
      converted <- FALSE
      
      #---convert numeric to boolean---
      if(convert_bool){
        u_vals <- unique(non_na_vals)
        
        if (all(u_vals %in% c(0,1))){
          df[[col_name]] <- as.logical(df[[col_name]])
          cols_changed <- c(cols_changed, paste0(col_name, " (-> Bool)"))
          converted <- TRUE
        }
      }
      if (converted) next
      
      #---convert numeric to categorical factor---
      
      n_unique <- length(unique(non_na_vals))
      n_total <- length(non_na_vals)
      
      #ensure column doesn't contain just 1 unique or all unique
      unique_ratio <- n_unique/n_total
      
      if(unique_ratio <= cat_threshold && n_unique > 1){
        df[[col_name]] <- as.factor(df[[col_name]])
        cols_changed <- c(cols_changed, paste0(col_name, " (-> Factor)"))
        converted <- TRUE
      }
      
      if (converted) next
      #---convert doubles to ints to save memory---
      if(convert_int && is.double(df[[col_name]])){
        if(all(non_na_vals %% 1 == 0)) {
          if(max(non_na_vals) < 2e9 && min(non_na_vals > -2e9)){
            df[[col_name]] <- as.integer(df[[col_name]])
            cols_changed <- c(cols_changed, paste0(col_name, "(-> Int)"))
          }
        }
      }
    }
    } #end of loop inside if statement
  
  #return new df
  x$data <- df
      
  #log the results
  if (length(cols_changed) > 0) {
    msg <- sprintf("Standardized Num Column Types: Converted %d columns: [%s]", length(cols_changed), paste(cols_changed, collapse = ", "))
    x$log <- c(x$log, msg)
  } else {
    x$log <- c(x$log, "Standardized Num Column Types: No columns met conversion conditions.")
  }
    
  return(x)
  
  }

```

```{r}
clean_text.MungrCleaner <- function(x, case = NULL, trim = TRUE, ...) {
  
  df <- x$data
  
  # Trim Whitespace & Fix Empty Strings
  if (trim) {
    df <- df |>
      dplyr::mutate(dplyr::across(where(is.character), stringr::str_trim)) |>
      dplyr::mutate(dplyr::across(where(is.character), ~ dplyr::na_if(., "")))
  }
  
  # Case Conversion (Optional)
  if (!is.null(case)) {
    # Select function based on string input
    case_func <- switch(tolower(case),
                        "lower" = tolower,
                        "upper" = toupper,
                        "title" = stringr::str_to_title,
                        NULL)
    
    if (!is.null(case_func)) {
      df <- df |>
        dplyr::mutate(dplyr::across(where(is.character), case_func))
    }
  }
  
  x$data <- df
  
  # 3. Log
  action_msg <- "Text cleaned (Empty -> NA)"
  
  if (trim) action_msg <- paste0(action_msg, ", Trimmed")
  if (!is.null(case)) action_msg <- paste0(action_msg, ", Case: ", case)
  x$log <- c(x$log, paste0(action_msg, ")"))
  
  return(x)
}
```

```{r}
impute_missing.MungrCleaner <- function(x, col_name = "",imp_type = "mean", num_val = 0, char_val = "Unknown", ...) {
  
  df <- x$data
  cols_changed <- character()
  
  if(col_name == ""){
    cols_to_process <- names(df)
  } else {
    if(!col_name %in% names(df)) stop(paste("Column", col_name, "not found."))
    cols_to_process <- col_name
  }
  
num_cols <- cols_to_process[sapply(df[cols_to_process], is.numeric)] 
char_cols <- cols_to_process[sapply(df[cols_to_process], is.character) | sapply(df[cols_to_process], is.factor)]
  
  # Helper function for Mode
  get_mode <- function(v) {
    v <- v[!is.na(v)]
    if(length(v) == 0) return(NA)
    uniqv <- unique(v)
    uniqv[which.max(tabulate(match(v, uniqv)))]
  }

  # --- A. Numeric Imputation ---
  if(length(num_cols) > 0 && imp_type != ""){
    
    impute_func <- switch(imp_type,
                        "mean" = function(.) ifelse(is.na(.), mean(., na.rm = TRUE), .),
                        "median" = function(.) ifelse(is.na(.), median(., na.rm = TRUE), .),
                        "mode" = function(.) ifelse(is.na(.), get_mode(.), .),
                        "custom_num" = function(.) tidyr::replace_na(., num_val),
                        NULL)
    
if (!is.null(impute_func)) {
      df <- df |>
        dplyr::mutate(dplyr::across(!!dplyr::all_of(num_cols), impute_func))
      cols_changed <- c(cols_changed, paste0(num_cols, " (Num Imputed)"))
    }
  }

  # --- B. Character Imputation (Custom Imputation Only) ---
  if (length(char_cols) > 0 && imp_type == "custom_char") {
    if (is.character(char_val) || is.factor(char_val)) {
      df <- df |>
        dplyr::mutate(dplyr::across(!!dplyr::all_of(char_cols), ~ tidyr::replace_na(., as.character(char_val))))
      cols_changed <- c(cols_changed, paste0(char_cols, " (Char Imputed)"))
    }
  }
  
  x$data <- df
  
  # Log
  if (length(cols_changed) > 0) {
    msg <- sprintf("Imputed Missing: %d columns changed: [%s]", 
                   length(cols_changed), paste(unique(cols_changed), collapse = ", "))
    x$log <- c(x$log, msg)
  } else {
    x$log <- c(x$log, "Imputed Missing: No changes made.")
  }

  return(x)
}
```

```{r}
quick_clean.MungrCleaner <- function(x, 
                                     clean_txt = TRUE, 
                                     std_coltypes = TRUE, 
                                     impute = TRUE,
                                     text_case = "title", 
                                     num_strategy = "median",
                                     ...) {
  
  x$log <- c(x$log, "--- START QUICK CLEAN ---")
  
  # 1. Text Cleaning
  if (clean_txt) {
    # We call the method defined in step 1
    x <- clean_text(x, case = text_case, trim = TRUE)
  }
  
  # Type Standardization
  if (std_coltypes) {
    # Check if methods exist before calling to prevent errors
    if (exists("standardize_strcols.MungrCleaner")) {
       x <- standardize_strcols(x, ...) 
    }
    if (exists("standardize_numcols.MungrCleaner")) {
       x <- standardize_numcols(x, ...)
    }
  }
  
  # 3. Imputation
  if (impute) {
    x <- impute_missing(x, num_val = num_strategy, char_val = "Unknown")
  }
  
  x$log <- c(x$log, "--- END QUICK CLEAN ---")
  
  # Return the clean dataframe directly (User friendliness)
  return(x)
}

```

